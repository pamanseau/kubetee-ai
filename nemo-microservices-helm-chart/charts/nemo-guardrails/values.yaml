# -- The number of replicas for the NeMo Guardrails microservice deployment.
replicaCount: 1

image:
  # -- The repository location of the NeMo Guardrails container image.
  repository: nvcr.io/nvidia/nemo-microservices/guardrails
  # -- The tag of the NeMo Guardrails container image.
  tag: ""
  # -- The image pull policy for the NeMo Guardrails container image.
  pullPolicy: IfNotPresent

# -- Specifies the list of secret names that are needed for the main container and any init containers.
imagePullSecrets:
  - name: nvcrimagepullsecret

# -- Overrides the chart name.
nameOverride: ""

# -- Overrides the full chart name.
fullnameOverride: ""

# -- Kubernetes secret containing NVIDIA_API_KEY for Guardrails to use Nemoguard NIMS on NVCF
guardrails:
  nvcfAPIKeySecretName: ""

# -- Environment variables for the container.
env:
  NIM_ENDPOINT_URL: "https://integrate.api.nvidia.com/v1"
  CONFIG_STORE_PATH: "/app/services/guardrails/config-store"
  DEFAULT_CONFIG_ID: "default"
  DEFAULT_LLM_PROVIDER: "nim"
  NEMO_GUARDRAILS_SERVER_ENABLE_CORS: "False"
  NEMO_GUARDRAILS_SERVER_ALLOWED_ORIGINS: "*"
  GUARDRAILS_HOST: "0.0.0.0"
  GUARDRAILS_PORT: "7331"
  DEMO: "False"

external:
  entityStore:
    # -- The external URL of the NeMo Entity Store microservice.
    endpoint: "http://nemo-entity-store:8000"

# -- Specifies the service type and the port for the deployment.
service:
  type: ClusterIP
  port: 7331

configStore:
  nfs:
    # -- Whether to enable the use of an NFS persistent volume for the configuration store.
    enabled: false
    # -- The path to the root of the Configuration Store folder.
    path: "/path/to/nfs/share"
    # -- The address of the NFS server.
    server: "nfs-server.example.com"
    # -- The path where the NFS volume will be mounted inside the container.
    mountPath: "/config-store"
    # -- The storage class for the PV and PVC.
    storageClass: "standard"

readinessProbe:
  # -- The HTTP GET request to use for the readiness probe.
  httpGet:
    path: /v1/health/ready
    port: 7331
  # -- The initial delay seconds for the readiness probe.
  initialDelaySeconds: 5
  # -- The timeout in seconds for the readiness probe.
  timeoutSeconds: 30

livenessProbe:
  # -- The HTTP GET request to use for the liveness probe.
  httpGet:
    path: /v1/health
    port: 7331
  # -- The initial delay seconds for the liveness probe.
  initialDelaySeconds: 5
  # -- The timeout in seconds for the liveness probe.
  timeoutSeconds: 30

serviceAccount:
  # -- Whether to create a service account for the NeMo Guardrails microservice.
  create: true
  # -- Whether to automatically mount the service account token.
  automount: true
  # -- Annotations to be added to the service account.
  annotations: {}
  # -- The name of the service account to use.
  name: ""

# -- Specifies additional annotations to the main deployment pods.
podAnnotations: {}

# -- Specifies additional labels to the main deployment pods.
podLabels: {}

# -- Specifies privilege and access control settings for the pod.
podSecurityContext: {}
# -- Specifies the group ID for the pod.
runAsGroup: ""
# -- Specifies the file system owner group id.
fsGroup: ""

# -- Specifies security context for the container.
securityContext: {}

ingress:
  # -- Whether to enable the ingress resource.
  enabled: false
  # -- The class name for the ingress resource.
  className: ""
  # -- Additional annotations for the ingress resource.
  annotations:
    {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  # -- (list) A list of maps, each containing the keys `host` and `paths` for the ingress resource. You must specify a list for configuring ingress for the microservice.
  # @default -- []
  hosts: {}
  #   - host: chart-example.local
  #     paths:
  #       - path: /
  #         pathType: ImplementationSpecific
  #         serviceType: openai # can be nemo or openai -- make sure your model serves the appropriate port(s)
  # -- TLS configuration for the ingress resource.
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# -- Specifies resource configurations for the deployment.
resources:
  {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# -- Specifies autoscaling configurations for the deployment.
autoscaling:
  # -- Whether to enable horizontal pod autoscaler.
  enabled: false
  # -- The minimum number of replicas for the deployment.
  minReplicas: 1
  # -- The maximum number of replicas for the deployment.
  maxReplicas: 100
  # -- The target CPU utilization percentage.
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# -- Specifies labels to ensure that the NeMo Guardrails microservice is deployed only on certain nodes. To learn more, refer to the [Node Selector](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector) in the Kubernetes documentation.
nodeSelector: {}

# -- Specifies tolerations for pod assignment. To learn more, refer to the [Taint and Toleration](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/) in the Kubernetes documentation.
tolerations: []

# -- Specifies affinity settings for the deployment. To learn more, refer to the [Affinity and Anti-Affinity](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity) in the Kubernetes documentation.
affinity: {}

# -- PostgreSQL configuration for the NeMo Guardrails microservice.
postgresql:
  # -- Whether to install the default PostgreSQL Helm chart. If enabled, the NeMo Guardrails microservice Helm chart uses the [PostgreSQL Helm chart from Bitnami](https://github.com/bitnami/charts/blob/main/bitnami/postgresql/values.yaml) to create a PostgreSQL database.
  enabled: true
  # -- The name override for the Guardrails PostgreSQL database.
  nameOverride: guardrailsdb
  # -- The architecture for the default PostgreSQL service.
  architecture: standalone
  serviceAccount:
    # -- The name of the service account for PostgreSQL.
    name: guardrails-postgresql
    # -- Specifies whether to create a new service account for PostgreSQL.
    create: true
  auth:
    # -- Whether to assign a password to the "postgres" admin user. If disabled, remote access is blocked for this user.
    enablePostgresUser: true
    # -- The user name to use for the PostgreSQL database.
    username: guardrails
    # -- The password for the PostgreSQL user.
    password: guardrails
    # -- The name for a custom database to create.
    database: nemo-guardrails
    # -- The name of an existing secret to use for PostgreSQL credentials.
    existingSecret: ""
postgresWaitImage:
  # -- The repository location of the image used to wait for postgres to start.
  repository: "busybox"
  # -- The tag of the image used when waiting.
  tag: "latest"

# -- External PostgreSQL configuration.
externalDatabase:
  # -- The database host.
  host: ""
  # -- The database port number.
  port: ""
  # -- The username for the NeMo Guardrails service.
  user: ""
  # -- The name of the database for the NeMo Guardrails service.
  database: ""
  # -- The name of an existing secret resource containing the database credentials.
  existingSecret: ""
  # -- The name of an existing secret key containing the database credentials.
  existingSecretPasswordKey: ""
  uriSecret:
    # -- The name of an existing secret that includes a full database URI.
    name: ""
    # -- The key within the existing secret that includes a full database URI.
    key: ""
